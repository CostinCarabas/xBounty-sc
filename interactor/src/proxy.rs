// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct XBountyProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for XBountyProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = XBountyProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        XBountyProxyMethods { wrapped_tx: tx }
    }
}

pub struct XBountyProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> XBountyProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init(
        self,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> XBountyProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> XBountyProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn fund<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        repo_owner: Arg0,
        repo_url: Arg1,
        issue_id: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("fund")
            .argument(&repo_owner)
            .argument(&repo_url)
            .argument(&issue_id)
            .original_result()
    }

    pub fn register<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        repo_owner: Arg0,
        repo_url: Arg1,
        issue_id: Arg2,
        solver_github: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("register")
            .argument(&repo_owner)
            .argument(&repo_url)
            .argument(&issue_id)
            .argument(&solver_github)
            .original_result()
    }

    pub fn release_bounty<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<u64>,
        Arg3: ProxyArg<ManagedAddress<Env::Api>>,
        Arg4: ProxyArg<ManagedBuffer<Env::Api>>,
    >(
        self,
        repo_owner: Arg0,
        repo_url: Arg1,
        issue_id: Arg2,
        solver_addr: Arg3,
        solver_github: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("releaseBounty")
            .argument(&repo_owner)
            .argument(&repo_url)
            .argument(&issue_id)
            .argument(&solver_addr)
            .argument(&solver_github)
            .original_result()
    }

    pub fn get_bounty<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        repo_owner: Arg0,
        repo_url: Arg1,
        issue_id: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Option<Bounty<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBounty")
            .argument(&repo_owner)
            .argument(&repo_url)
            .argument(&issue_id)
            .original_result()
    }

    pub fn bounties<
        Arg0: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<u64>,
    >(
        self,
        repo_owner: Arg0,
        repo_url: Arg1,
        issue_id: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, Bounty<Env::Api>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getBountyIds")
            .argument(&repo_owner)
            .argument(&repo_url)
            .argument(&issue_id)
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, Debug)]
pub struct Bounty<Api>
where
    Api: ManagedTypeApi,
{
    pub repo_url: ManagedBuffer<Api>,
    pub issue_id: u64,
    pub repo_owner: ManagedBuffer<Api>,
    pub amount: BigUint<Api>,
    pub proposer: ManagedAddress<Api>,
    pub solvers: ManagedVec<Api, Solver<Api>>,
    pub status: BountyStatus,
    pub created_at: u64,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, Clone, Debug, ManagedVecItem, PartialEq)]
pub struct Solver<Api>
where
    Api: ManagedTypeApi,
{
    pub solver_addr: ManagedAddress<Api>,
    pub solver_github: ManagedBuffer<Api>,
}

#[type_abi]
#[derive(TopEncode, TopDecode, NestedEncode, NestedDecode, PartialEq, Clone, Debug)]
pub enum BountyStatus {
    Funded,
    Registered,
    Completed,
}
